module Nar.Random

def int(a: Int, b: Int): Generator[Int] =
  GeneratorImpl(
    \(seed0) ->
      let ( lo, hi ) = if a < b then ( a, b ) else ( b, a )
      let range = hi - lo + 1
      in
        if ((range - 1) & range) == 0 then
          ( Bitwise.shiftRightZfBy(0, (range - 1) & peel(seed0)) + lo, next(seed0) )
        else
          let threshhold = Bitwise.shiftRightZfBy(0, remainderBy(range, Bitwise.shiftRightZfBy(0, -range)))
          let accountForBias(seed: Seed): ( Int, Seed ) =
            let x = peel(seed)
            let seedN = next(seed)
            in
              if x < threshhold then
                accountForBias(seedN)
              else
                ( remainderBy(range, x + lo), seedN )
          in
            accountForBias(seed0)
  )

def maxInt: Int = 2147483647

def minInt : Int = -2147483648

def float(a: Float, b: Float): Generator[Float] =
  GeneratorImpl(
    \(seed0) ->
      let seed1 = next(seed0)
      let n0 = peel(seed0)
      let n1 = peel(seed1)
      let hi = Math.toFloat(0x03FFFFFF & n0) * 1.0
      let lo = Math.toFloat(0x07FFFFFF & n1) * 1.0
      let val = ((hi * 134217728.0) + lo) / 9007199254740992.0
      let range = abs(b - a)
      let scaled = val * range + a
      in ( scaled, next(seed1) )
  )

def constant(value: a): Generator[a] =
  GeneratorImpl(\(seed) -> (value, seed))

def pair(genA: Generator[a], genB: Generator[b]): Generator[(a,b)] =
  map2(\(a, b) -> (a,b), genA, genB)

def list(n: Int, GeneratorImpl(gen): Generator[a]): Generator[List[a]] =
  GeneratorImpl( \(seed) -> listHelp([], n, gen, seed) )

def hidden listHelp(revList: List[a], n: Int, gen: (Seed): (a, Seed), seed: Seed): (List[a], Seed) =
  if n < 1 then
    (revList, seed)
  else
    let (value, newSeed) = gen(seed)
    in listHelp(value | revList, n-1, gen, newSeed)

def uniform(value: a, valueList: List[a]): Generator[a] =
  weighted(addOne(value), List.map(addOne, valueList))

def hidden addOne(value: a): (Float, a) =
  ( 1, value )

def weighted(first: (Float, a), others: List[(Float, a)]): Generator[a] =
  let normalize( (weight, _) ) = abs(weight)
  let total = normalize(first) + List.sum(List.map(normalize, others))
  in map(getByWeight(first, others), float(0, total))

def hidden getByWeight((weight, value): (Float, a), others: List[(Float, a)], countdown: Float): a =
  select others
    case [] -> value
    case second | otherOthers ->
      if countdown <= abs(weight) then
        value
      else
        getByWeight(second, otherOthers, countdown - abs(weight))
  end

def map(func: (a): b, GeneratorImpl(genA): Generator[a]): Generator[b] =
  GeneratorImpl(
    \(seed0) ->
      let (a, seed1) = genA(seed0)
      in (func(a), seed1)
  )

def map2(
  func: (a, b): c,
  GeneratorImpl(genA): Generator[a],
  GeneratorImpl(genB): Generator[b]
): Generator[c] =
  GeneratorImpl(
    \(seed0) ->
      let (a, seed1) = genA(seed0)
      let (b, seed2) = genB(seed1)
      in (func(a, b), seed2)
  )

def map3(
  func: (a, b, c): d,
  GeneratorImpl(genA): Generator[a],
  GeneratorImpl(genB): Generator[b],
  GeneratorImpl(genC): Generator[c]
): Generator[d] =
  GeneratorImpl(
    \(seed0) ->
      let (a, seed1) = genA(seed0)
      let (b, seed2) = genB(seed1)
      let (c, seed3) = genC(seed2)
      in (func(a, b, c), seed3)
  )


def map4(
  func: (a, b, c, d): e,
  GeneratorImpl(genA): Generator[a],
  GeneratorImpl(genB): Generator[b],
  GeneratorImpl(genC): Generator[c],
  GeneratorImpl(genD): Generator[d]
): Generator[e] =
  GeneratorImpl(
    \(seed0) ->
      let (a, seed1) = genA(seed0)
      let (b, seed2) = genB(seed1)
      let (c, seed3) = genC(seed2)
      let (d, seed4) = genD(seed3)
      in (func(a, b, c, d), seed4)
  )

def map5(
  func: (a, b, c): d,
  GeneratorImpl(genA): Generator[a],
  GeneratorImpl(genB): Generator[b],
  GeneratorImpl(genC): Generator[c],
  GeneratorImpl(genD): Generator[d],
  GeneratorImpl(genE): Generator[e]
): Generator[f] =
  GeneratorImpl(
    \(seed0) ->
      let (a, seed1) = genA(seed0)
      let (b, seed2) = genB(seed1)
      let (c, seed3) = genC(seed2)
      let (d, seed4) = genC(seed3)
      let (e, seed5) = genC(seed4)
      in (func(a, b, c, d, e), seed5)
  )

def andThen(callback: (a): Generator[b], GeneratorImpl(genA):Generator[a]): Generator[b] =
  GeneratorImpl(
    \(seed) ->
      let (result, newSeed) = genA(seed)
      let GeneratorImpl(genB) = callback(result)
      in genB(newSeed)
  )

def lazy(callback:(()): Generator[a]): Generator[a] =
  GeneratorImpl(
    \(seed) ->
      let GeneratorImpl(gen) = callback( () )
      in gen(seed)
  )

type hidden Seed
  = SeedImpl(Int, Int)

def hidden next(SeedImpl(state0, incr): Seed): Seed =
  SeedImpl(Bitwise.shiftRightZfBy(0, state0 * 1664525 + incr), incr)

def hidden peel(SeedImpl(state, _): Seed): Int =
  let word = Bitwise.xor(state, Bitwise.shiftRightZfBy(Bitwise.shiftRightZfBy(28, state) + 4, state)) * 277803737
  in Bitwise.shiftRightZfBy(0, Bitwise.xor(Bitwise.shiftRightZfBy(22, word), word))

type Generator[a]
  = hidden GeneratorImpl((Seed): ( a, Seed ))

def hidden step(GeneratorImpl(generator): Generator[a], seed: Seed): (a, Seed) =
  generator(seed)

def hidden initialSeed(x: Int): Seed =
  let SeedImpl(state1, incr) = next(SeedImpl(0, 1013904223))
  let state2 = Bitwise.shiftRightZfBy(0, state1 + x)
  in next(SeedImpl(state2, incr))

def hidden independentSeed : Generator[Seed] =
  GeneratorImpl <|
    \(seed0) ->
      let gen = int(0, 0xFFFFFFFF)
      let makeIndependentSeed(state, b, c) =
        next <| SeedImpl(state) <| Bitwise.shiftRightZfBy(0, 1 % (b ^ c))
      in
        step(map3(makeIndependentSeed, gen, gen, gen), seed0)
